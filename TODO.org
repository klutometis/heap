* TODO Use =max= instead of =extremum=?
  I.e., with the understanding that it's inverted in a min-heap.
* TODO Membership testing with an adherent hash-table?
* TODO SRFI
  Why aren't there SRFIs about the fundamental datatypes: queues,
  stacks, heaps?
* TODO Use vectors instead of lists.
  #+BEGIN_SRC scheme
    (use (only aima define-record-and-printer)
         debug
         miscmacros
         test
         vector-lib)
    
    (define (parent i)
      (- (inexact->exact (floor (/ (+ i 1) 2))) 1))
    
    (define (left i)
      (+ (* 2 i) 1))
    
    (define (right i)
      (+ (* 2 i) 1 1))
    
    (define-record-and-printer heap
      >?
      inf
      key
      key-set!
      data
      size)
    
    (define (heap-length heap)
      (vector-length (heap-data heap)))
    
    (define (heap-ref heap i)
      (vector-ref (heap-data heap) i))
    
    (define (heap-set! heap i x)
      (vector-set! (heap-data heap) i x))
    
    (define (heap-swap! heap i j)
      (vector-swap! (heap-data heap) i j))
    
    (define (heapify! heap i)
      (let ((heap->? (heap->? heap))
            (heap-key (heap-key heap)))
        (let ((left (left i))
              (right (right i)))
          (let* ((extremum (if (and (< left (heap-size heap))
                                    (heap->?
                                     (heap-key (heap-ref heap left))
                                     (heap-key (heap-ref heap i))))
                               left
                               i))
                 (extremum (if (and (< right (heap-size heap))
                                    (heap->?
                                     (heap-key (heap-ref heap right))
                                     (heap-key (heap-ref heap extremum))))
                               right
                               extremum)))
            (if (not (= extremum i))
                (begin (heap-swap! heap i extremum)
                       (heapify! heap extremum)))))))
    
    (define-record-and-printer element key datum)
    
    (define initial-heap-size (make-parameter 100))
    
    (define make-max-heap
      (case-lambda
       (()
        (make-max-heap car set-car!))
       ((key key-set!)
        (make-max-heap key key-set! (make-vector (initial-heap-size)) 0))
       ((key key-set! data)
        ;; It's always 0 here, isn't it, unless we're passing in a valid
        ;; heap? In which case: use the constructor directly.
        ;;
        ;; Should we build the heap automatically?
        (make-max-heap key key-set! data (vector-length data)))
       ((key key-set! data size)
        (make-heap > -inf key key-set! data length))))
    
    (define (figure-6.2)
      (let ((data (list->vector (map list '(16 4 10 14 7 9 3 2 8 1)))))
        (make-max-heap car set-car! data)))
    
    (define (test-figure-6.2 testandum heap)
      (test testandum
            '#((16) (14) (10) (8) (7) (9) (3) (2) (4) (1))
            (heap-data heap)))
    
    (let ((heap (figure-6.2)))
      (heapify! heap 1)
      (test-figure-6.2 "heapify!" heap))
    
    (define (build-heap! heap)
      (heap-size-set! heap (vector-length (heap-data heap)))
      (let ((median (inexact->exact (floor (/ (heap-size heap) 2)))))
        ;; Should be i - 1 here?
        (do ((i (sub1 median) (sub1 i)))
            ((negative? i))
          (heapify! heap i))))
    
    (let ((heap (figure-6.2)))
      (build-heap! heap)
      (test-figure-6.2 "build-heap!" heap))
    
    (define (heap-extremum heap)
      (heap-ref heap 0))
    
    (define (heap-extract-extremum! heap)
      (if (zero? (heap-size heap))
          (error "Heap underflow -- HEAP-EXTRACT-EXTREMUM!")
          (let ((extremum (heap-extremum heap)))
            (heap-set! heap 0 (heap-ref heap (- (heap-size heap) 1)))
            (heap-size-set! heap (- (heap-size heap) 1))
            (heapify! heap 0)
            extremum)))
    
    (let ((heap (figure-6.2)))
      (build-heap! heap)
      (test "heap-extremum" '(16) (heap-extremum heap))
      (test "heap-extract-extremum! -- extremum" '(16) (heap-extract-extremum! heap))
      (test "heap-extract-extremum! -- data"
            '#((14) (8) (10) (4) (7) (9) (3) (2) (1) (1))
            (heap-data heap)))
    
    (define (heap-change-key! heap i key)
      (let ((heap->? (heap->? heap))
            (heap-key (heap-key heap)))
        (if (heap->? key (heap-key (heap-ref heap i)))
            (begin
              ((heap-key-set! heap) (heap-ref heap i) key)
              (do ((i i (parent i)))
                  ((or (negative? i)
                       (heap->? (heap-key (heap-ref heap (parent i)))
                                (heap-key (heap-ref heap i)))))
                (heap-swap! heap i (parent i))))
            (error "Key violates heap-gradient -- HEAP-CHANGE-KEY!"))))
    
    (define (figure-6.5)
      (let ((data (list->vector (map list '(16 14 10 8 7 9 3 2 4 1)))))
        (make-max-heap car set-car! data)))
    
  #+END_SRC
* TODO Dynamic resizing
  Do it exponentially.
* DONE Payload mechanism
  CLOSED: [2012-09-26 Wed 01:33]
