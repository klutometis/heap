* TODO Don't expose the =.../index= functions.
  We only really care about data, don't we? =.../index= is
  implementation.
* DONE Membership testing with an adherent hash-table?
  CLOSED: [2012-09-27 Thu 05:31]
* DONE Use vectors instead of lists.
  CLOSED: [2012-09-27 Thu 05:31]
  #+BEGIN_SRC scheme
    (use (only aima define-record-and-printer)
         debug
         miscmacros
         test
         vector-lib)
    
    (define (parent i)
      (- (inexact->exact (floor (/ (+ i 1) 2))) 1))
    
    (define (left i)
      (+ (* 2 i) 1))
    
    (define (right i)
      (+ (* 2 i) 1 1))
    
    (define-record-and-printer heap
      >?
      =?
      inf
      key
      key-set!
      data
      size)
    
    (define (heap-length heap)
      (vector-length (heap-data heap)))
    
    (define (heap-ref heap i)
      (vector-ref (heap-data heap) i))
    
    (define (heap-set! heap i x)
      (vector-set! (heap-data heap) i x))
    
    (define (heap-swap! heap i j)
      (vector-swap! (heap-data heap) i j))
    
    (define (heapify! heap i)
      (let ((heap->? (heap->? heap))
            (heap-key (heap-key heap)))
        (let ((left (left i))
              (right (right i)))
          (let* ((extremum (if (and (< left (heap-size heap))
                                    (heap->?
                                     (heap-key (heap-ref heap left))
                                     (heap-key (heap-ref heap i))))
                               left
                               i))
                 (extremum (if (and (< right (heap-size heap))
                                    (heap->?
                                     (heap-key (heap-ref heap right))
                                     (heap-key (heap-ref heap extremum))))
                               right
                               extremum)))
            (if (not (= extremum i))
                (begin (heap-swap! heap i extremum)
                       (heapify! heap extremum)))))))
    
    (define-record-and-printer element key datum)
    
    (define initial-heap-size (make-parameter 100))
    
    (define make-max-heap
      (case-lambda
       (()
        (make-max-heap car set-car!))
       ((key key-set!)
        (make-max-heap key key-set! (make-vector (initial-heap-size)) 0))
       ((key key-set! data)
        ;; It's always 0 here, isn't it, unless we're passing in a valid
        ;; heap? In which case: use the constructor directly.
        ;;
        ;; Should we build the heap automatically?
        (make-max-heap key key-set! data (vector-length data)))
       ((key key-set! data size)
        (make-heap > = -inf key key-set! data size))))
    
    (define (figure-6.2)
      (let ((data (list->vector (map list '(16 4 10 14 7 9 3 2 8 1)))))
        (make-max-heap car set-car! data)))
    
    (define (test-figure-6.2 testandum heap)
      (test testandum
            '#((16) (14) (10) (8) (7) (9) (3) (2) (4) (1))
            (heap-data heap)))
    
    (let ((heap (figure-6.2)))
      (heapify! heap 1)
      (test-figure-6.2 "heapify!" heap))
    
    (define (build-heap! heap)
      (heap-size-set! heap (vector-length (heap-data heap)))
      (let ((median (inexact->exact (floor (/ (heap-size heap) 2)))))
        ;; Should be i - 1 here?
        (do ((i (sub1 median) (sub1 i)))
            ((negative? i))
          (heapify! heap i))))
    
    (let ((heap (figure-6.2)))
      (build-heap! heap)
      (test-figure-6.2 "build-heap!" heap))
    
    (define (heap-extremum heap)
      (heap-ref heap 0))
    
    (define (heap-extract-extremum! heap)
      (if (zero? (heap-size heap))
          (error "Heap underflow -- HEAP-EXTRACT-EXTREMUM!")
          (let ((extremum (heap-extremum heap)))
            (heap-set! heap 0 (heap-ref heap (- (heap-size heap) 1)))
            (heap-size-set! heap (- (heap-size heap) 1))
            (heapify! heap 0)
            extremum)))
    
    (let ((heap (figure-6.2)))
      (build-heap! heap)
      (test "heap-extremum" '(16) (heap-extremum heap))
      (test "heap-extract-extremum! -- extremum" '(16) (heap-extract-extremum! heap))
      (test "heap-extract-extremum! -- data"
            '#((14) (8) (10) (4) (7) (9) (3) (2) (1) (1))
            (heap-data heap)))
    
    (define (heap-change-key! heap i new-key)
      (let ((heap->? (heap->? heap))
            (heap-=? (heap-=? heap))
            (heap-key (heap-key heap)))
        (let ((old-key (heap-key (heap-ref heap i))))
          (if (or (heap->? new-key old-key)
                  (heap-=? new-key old-key))
              (begin
                ((heap-key-set! heap) (heap-ref heap i) new-key)
                (do ((i i (parent i)))
                    ;; Do we also need to check for (negative? i)?
                    ((or (zero? i)
                         (heap->? (heap-key (heap-ref heap (parent i)))
                                  (heap-key (heap-ref heap i)))))
                (heap-swap! heap i (parent i))))
              (error "Key violates heap-gradient -- HEAP-CHANGE-KEY!")))))
    
    (define (figure-6.5)
      (let ((data (list->vector (map list '(16 14 10 8 7 9 3 2 4 1)))))
        (make-max-heap car set-car! data)))
    
    (let ((heap (figure-6.5)))
      (heap-change-key! heap 8 15)
      (test "heap-change-key!"
            '#((16) (15) (10) (14) (7) (9) (3) (2) (8) (1))
            (heap-data heap)))
    
    (define (heap-insert! heap element)
      (let ((heap-size (heap-size heap)))
        (if (= heap-size (heap-length heap))
            (heap-data-set! heap (vector-resize (heap-data heap) (* 2 heap-size))))
        (heap-size-set! heap (+ heap-size 1))
        (let ((key ((heap-key heap) element)))
          ((heap-key-set! heap) element (heap-inf heap))
          (heap-set! heap heap-size element)
          (heap-change-key! heap heap-size key))))
    
    (let ((heap (figure-6.5)))
      (heap-insert! heap '(21))
      (test "heap-insert!"
            '#((21)
               (16)
               (10)
               (8)
               (14)
               (9)
               (3)
               (2)
               (4)
               (1)
               (7)
               #f
               #f
               #f
               #f
               #f
               #f
               #f
               #f
               #f)
            (heap-data heap)))
    
    (define (heap-delete! heap i)
      ;; Hypothesis
      (let ((heap-size (- (heap-size heap) 1)))
        (if (negative? heap-size)
            (error "Heap underflow -- HEAP-DELETE!")
            (begin
              (heap-size-set! heap heap-size)
              (heap-set! heap i (heap-ref heap heap-size))
              (heapify! heap i)))))
    
    (let ((heap (figure-6.5)))
      (heap-delete! heap 4)
      (test "heap-delete!"
            '#((16) (14) (10) (8) (1) (9) (3) (2) (4) (1))
            (heap-data heap)))
  #+END_SRC
* DONE Dynamic resizing
  CLOSED: [2012-09-27 Thu 05:31]
  Do it exponentially.
* DONE Payload mechanism
  CLOSED: [2012-09-26 Wed 01:33]
* CANCELED Use =max= instead of =extremum=?
  CLOSED: [2012-09-27 Thu 05:31]
  I.e., with the understanding that it's inverted in a min-heap.
* CANCELED SRFI
  CLOSED: [2012-09-27 Thu 05:31]
  - CLOSING NOTE [2012-09-27 Thu 05:31] \\
    Good question.
  Why aren't there SRFIs about the fundamental datatypes: queues,
  stacks, heaps?
